/*
Copyright 2020 Twitter, Inc.
SPDX-License-Identifier: Apache-2.0

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
https://openapi-generator.tech
Do not edit the class manually.
*/


package com.twitter.clientlib.stream;


import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.stream.IntStream;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import com.twitter.clientlib.model.StreamingTweet;

public class TweetsStreamExecutor {
  private volatile BlockingQueue<String> rawTweets;
  private volatile BlockingQueue<StreamingTweet> tweets;
  private volatile boolean isRunning = true;

  private ExecutorService executorService;
  private final List<TweetsStreamListener> listeners = new ArrayList<>();
  private final InputStream stream;

  public TweetsStreamExecutor(InputStream stream) {
    this.rawTweets = new LinkedBlockingDeque<>();
    this.tweets = new LinkedBlockingDeque<>();
    this.stream = stream;
  }

  public void addListener(TweetsStreamListener toAdd) {
    listeners.add(toAdd);
  }

  public void removeListener(TweetsStreamListener toRemove) {
    listeners.remove(toRemove);
  }

  public void start() {
    if (stream == null) {
      System.out.println("Error: stream is null.");
      return;
    }

    RawTweetsQueuer rawTweetsQueuer = new RawTweetsQueuer();
    TweetsListenersExecutor tweetsListenersExecutor = new TweetsListenersExecutor();
    rawTweetsQueuer.start();
    int threads = 5; //TODO parametrize this
    executorService = Executors.newFixedThreadPool(threads);
    for (int i = 0; i < threads; i++) {
      executorService.submit(new ParseTweetsTask());
    }
    tweetsListenersExecutor.start();
  }

  public synchronized void shutdown() {
    isRunning = false;
    executorService.shutdown();
    System.out.println("TweetsStreamListenersExecutor is shutting down.");
  }

  private class TweetsListenersExecutor extends Thread {
    @Override
    public void run() {
      processTweets();
    }

    private void processTweets() {
      StreamingTweet streamingTweet;
      try {
        while (isRunning) {
          streamingTweet = tweets.poll();
          if (streamingTweet == null) {
            Thread.sleep(100);
            continue;
          }
          for (TweetsStreamListener listener : listeners) {
            listener.actionOnTweetsStream(streamingTweet);
          }
        }
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }

  private class ParseTweetsTask implements Runnable {
    private final ObjectMapper objectMapper;
    private ParseTweetsTask() {
      this.objectMapper = new ObjectMapper();
      objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }

    @Override
    public void run() {
      while (isRunning) {
        try {
          String rawTweet = rawTweets.take();
          StreamingTweet tweet = objectMapper.readValue(rawTweet, StreamingTweet.class);
          tweets.put(tweet);
        } catch (InterruptedException e) {
          System.out.println("Fail 1");
        } catch (JsonMappingException e) {
          System.out.println("Fail 2");
        } catch (JsonProcessingException e) {
          System.out.println("Fail 3");
        }
      }
    }
  }

  private class RawTweetsQueuer extends Thread {

    @Override
    public void run() {
      queueTweets();
    }

    public void queueTweets() {

      String line = null;
      try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {
        while (isRunning) {
          line = reader.readLine();
          if(line == null || line.isEmpty()) {
            Thread.sleep(100);
            continue;
          }
          try {
            rawTweets.put(line);
          } catch (Exception interExcep) {
            interExcep.printStackTrace();
          }
        }
      } catch (Exception e) {
        e.printStackTrace();
        shutdown();
      }
    }
  }
}

